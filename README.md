# lg_stage01_module05

# Java 新特性和项目

# 一、常用设计原则和设计模式
## 1. 常用的设计原则
### 1.1 软件的开发流程
* 需求分析文档、概要设计文档、详细设计文档、编码和测试、安装和调试、维护和升级

### 1.2 常用的设计原则
* 开闭原则：对扩展开放对修改关闭，为了扩展性好，易于维护和升级
* 里氏替换原则：任何基类出现的地方，子类一定可以出现，使用多态的方式
* 依赖倒转原则：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性
* 接口隔离原则：尽量多使用小接口而不是打接口，避免接口污染，降低类之间的耦合度（高内聚、低耦合）
* 迪米特法则（最少知道原则）：一个实体应当尽量少与其他实体之间发生相互作用，使系统功能相对独立
* 合成复用原则：尽量多使用合成/聚合的方式，而不是继承的方式

## 2. 常用的设计模式
### 2.1 基本概念
* 设计模式是一套反复被使用、多数人知晓的、经过分类编目的、代码设计经验的总结
* 设计模式就是一种用于固定场合的固定套路

### 2.2 基本分类
* 创建型模式：单例设计模式、工厂方法模式、抽象工厂方法...
* 结构型设计模式：装饰器模式、代理模式...
* 行为型模式：模版设计模式...

## 3. 设计模式详解
### 3.1 单例模式
### 3.2 普通工厂模式
### 3.3 多个工厂方法模式
### 3.4 静态工厂方法模式
### 3.5 抽象工厂模式
### 3.6 装饰器模式
#### 3.6.1 基本概念
* 装饰器模式就是给一个对象动态的增加一些新功能，要求装饰器对象和被装饰对象实现同一个接口，装饰器对象持有被装饰对象的实例。

#### 3.6.2 实际意义
* 实现一个类功能的扩展
* 动态增加功能，还能动态撤销
* 缺点：产生过多相似的对象，不易排错

### 3.7 代理模式
#### 3.7.1 基本概念
* 代理模式就是找一个代理类替换原对象进行一些操作

#### 3.7.2 实际意义
* 如果在使用的时候需要对原有的方法进行改进，可以采用一个代理类调用原方法，并且对产生的结果进行控制，这种方式就是代理模式
* 代理模式可以将功能划分更加清晰，有助于后期维护

#### 3.7.3 代理模式和装饰器模式的比较
* 装饰器模式是通常将原始对象作为一个参数传给装饰者的构造器，代理模式在一个代理类中创建一个被代理的对象
* 装饰器关注于在一个对象上动态的添加方法，代理模式关注于控制对象的访问

### 3.8 模板方法模式
####  3.8.1 基本概念
* 模版方法模式主要指一个抽象类中封装了一个固定的流程，流程中的具体步骤可以由不同子类进行不同实现，通过抽象类让固定的流程产生不同非结果

####  3.8.2 实际意义
* 将多个子共有的且逻辑基本相同的内容提取出来实现代码复用
* 不同的子类实现不同的效果形成多态，有助于后期维护

# 二、新特性

## 1. Java8 新特性
### 1.1 Java8的概述
### 1.2 函数式接口
* 函数式接口是只包含一个抽象方法非接口
* Java8提供@FunctionalInterface注解来定义函数式接口，若定义接口不符合函数式的规范会报错
* Java8中增加了java.util.function包，包含了常用的函数式接口

| 接口名称 | 方法声明 | 功能介绍 |
| --- | --- | --- |
| Consumer<T> | void accept(T t) | 根据指定的参数执行操作 |
| Supplier<T> | T get() | 得到一个返回值 |
| Function<T, R> | R apply(T t) | 根据指定参数执行操作并返回 |
| Predicate<T> | boolean test(T t) | 判断指定的参数是否满足条件 |

### 1.3 Lambda表达式
* Lambda表达式是实例化函数式接口的重要方式，使用Lambda表达式可以使代码变得更加简洁紧凑

### 1.4 方法引用
* 方法引用主要指通过方法的名字来指向一个方法而不需要为方法提供方法体，该方法的调用交给函数式接口执行
* 方法引用使用一对冒号（::）将类或对象的方法名进行连接：  
    * 对象的非静态方法的引用    ObjectName::MethodName
    * 类的静态方法的引用    ClassName::StaticMethodName
    * 类的非静态方法的引用    ClassName::MethodName
    * 构造器的引用    ClassName::new
    * 数组的引用    TypeName[]::new
* 方法引用是在特定场景下Lambda表达式的一种简化表示，可以进一步简化代码编写，使代码更加紧凑整洁

### 1.5 Stream接口

### 1.6 Optional类
#### 1.6.1 基本概念
* java.util.Optional类可以理解为一个简单的容器，其值可能是null或者不是null，代表一个值存在或者不存在
* 该类可以很好的解决指针异常，不用显示进行空值检测 

#### 1.6.2 常用方法
| 方法声明 | 功能介绍 |
| --- | --- |
| static \<T\> Optional\<T\> ofNull(T value) | 根据指定参数来得到Optional类型的对象 |
| \<U\> Optional\<U\> map(Function\<? super T, ? extends U\> | 根据参数指定规则的结果得到Optional类型的对象 | 
| T orElse(T other) | 若该值存在则返回，否则返回other的数值 |

## 2. Java9新特性
### 2.1 概述
* 模块化系统，模块就是代码和数据的封装体，模块的代码被组织称多个包，每个包中包含Java类和接口，模块的数据则包括资源文件和其他静态信息

### 2.2 模块化的使用
#### 2.2.1 语法格式
* 在module-info.java文件中
```java
module 模块名 {
    exports 需要暴露的包名; 
}
```

```java
module 模块名 {
    requires 模块名;
}
```

#### 2.2.2 模块化的优势
* 减少内存的开销
* 简化各种类库和大型应用的开发和维护
* 安全性、可维护性、提高性能

### 2.3 钻石操作符的使用升级
* 允许匿名内部类的使用中使用钻石操作符

```java
public class DiamondTest {

    public static void main(String[] args) {
        // 匿名内部类和钻石操作符的搭配使用
        // Explicit 明确的; 清楚明白的; 易于理解的; (说话)清晰的; 直言的; 坦率的; 不隐晦的; 不含糊的;
        // Comparator<Integer> comparator = new Comparator<Integer>() { // Explicit type argument Integer can be replaced with <>
        Comparator<Integer> comparator = new Comparator<>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return 0;
            }
        };

    }
}
```

### 2.4 集合工厂方法
#### 2.4.1 基本概念
* Java9的List、Set和Map集合中增加了静态工厂方法of实现不可变实例的创建
* 不可变体现在无法添加、修改和删除它们的元素
* 不允许添加null元素

#### 2.4.2 实际意义
* 保证线程安全
* 被不可信的类库使用时会很安全
* 不需要支持修改的对象节省时间和空间的开销
* 可当作常量来对待，并且这个对象以后也不会被改变

### 2.5 InputStream的增强
* InputStream类中提供了transferTo方法实现将数据直接传输到OutputStream中


## 3. Java10新特性
### 3.1 Java10概述
* 一个本地类型推断、一个垃圾回收的增强

### 3.2 局部变量类型推断
#### 3.2.1 基本概念
* 使用var作为局部变量类型推断标识符，仅适用于局部变量、增强for循环的索引、以及传统for循环的本地变量
* 不能用于方法的形式参数、构造参数的形式参数、方法的返回类型、字段、catch形式参数或任何其他类型的变量声明

#### 3.2.2 实际意义
* 标识符var不是关键字
* 避免了信息的冗余
* 对齐了变量名
* 更容易阅读

## 4. Java11新特性
### 4.1 概述
* 长期支持版

### 4.2 简化的编译运行操作
* 使用java命令一次性进行编译和运行
* 执行源文件中的第一个类必须包含主方法
* 不可以使用其他源文件中自定义的类

### 4.3 String类新增方法
| 方法声明 | 功能介绍 |
| --- | --- |
| boolean isBlank() | 判断字符串是否为空或者包含空白代码点 |
| <U>Optional<U> map(Function<? super T,? extends U> | 根据指定规则的结果来得到Optional类型的对象 |
| T orElse(T other) | 若该值存在就返回，否则返回other |

 

